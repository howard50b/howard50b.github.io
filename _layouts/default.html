<html>
<head>
    <title>{{ page.title }}</title>
    <meta charset='UTF-8'>
    <meta content='width=device-width, initial-scale=1' name='viewport'/>

    <meta name='description' content='Gregory Gundersen is a PhD candidate at Princeton.'>
    <meta name='keywords' content='{{ page.keywords }}'>
    <meta name='author' content='Gregory Gundersen'>

    <link rel='shortcut icon' href='/favicon.png' />
    <link href='/css/blog.css' rel='stylesheet'/>
    <link href='/css/trac.css' rel='stylesheet'/>
    <link href='/css/markdown.css' rel='stylesheet'/>

    {% include mathjax.html %}
</head>
<body>
<div class='content'>
    {% include nav.html %}
    <div class='front-matter'>
        <div class='wrap'>
            <h1>{{ page.title }}</h1>
            <div class='bylines'>
                <div class='byline'>
                    <h3>Published</h3>
                    <p>{{ page.date | date: '%d %b %Y' }}</p>
                </div>
            </div>
            <div class='clear'></div>
        </div>
    </div>
    <div class='article-container'>
        <div class='wrap article'>
            {{ content }}
        </div>
        <nav class='toc-nav' id='toc-nav'>
            <div class='toc-header'>Contents</div>
            <ul class='toc-list' id='toc-list'></ul>
        </nav>
    </div>
</div>
<script>
// Auto-filter bibliography: only show cited references, renumber automatically
document.addEventListener('DOMContentLoaded', function() {
  // Find bibliography source (ul or ol after ## References)
  const bibSource = document.querySelector('.bib-source ul, .bib-source ol');
  if (!bibSource) {
    // Fallback to old ol.bibliography format
    const bibList = document.querySelector('ol.bibliography');
    if (bibList) filterOldFormat(bibList);
    return;
  }

  // Find all citation links in the article
  const article = document.querySelector('.article');
  const citationLinks = article.querySelectorAll('a[href^="#"]');
  
  // Collect cited reference IDs in order of appearance and track first occurrence
  const citedIdsOrdered = [];
  const citedIdsSet = new Set();
  const firstCitationId = new Map(); // Maps ref id -> first citation element id
  
  citationLinks.forEach((link, index) => {
    const id = link.getAttribute('href').substring(1);
    if (!id) return;
    
    // Add unique id to citation link for back-linking
    const citationId = 'cite-' + id + '-' + index;
    link.id = citationId;
    
    if (!citedIdsSet.has(id)) {
      citedIdsSet.add(id);
      citedIdsOrdered.push(id);
      firstCitationId.set(id, citationId);
    }
  });

  // Build a map of id -> list item content
  const refMap = new Map();
  const items = bibSource.querySelectorAll('li');
  items.forEach(item => {
    const code = item.querySelector('code');
    if (!code) return;
    
    const id = code.textContent.trim();
    code.remove();
    refMap.set(id, item.innerHTML.trim());
  });

  // Create new ordered list for bibliography, sorted by appearance in text
  const newList = document.createElement('ol');
  newList.className = 'bibliography';
  
  citedIdsOrdered.forEach(id => {
    if (!refMap.has(id)) return;
    
    const li = document.createElement('li');
    const backLinkId = firstCitationId.get(id);
    const backLink = backLinkId ? ' <a href="#' + backLinkId + '" class="back-link" title="Back to text">â†©</a>' : '';
    li.innerHTML = '<a name="' + id + '"></a>' + refMap.get(id) + backLink;
    newList.appendChild(li);
  });

  // Replace source with formatted bibliography
  bibSource.parentNode.replaceChild(newList, bibSource);
});

function filterOldFormat(bibList) {
  const article = document.querySelector('.article');
  const citationLinks = article.querySelectorAll('a[href^="#"]');
  const citedIds = new Set();
  citationLinks.forEach(link => {
    const id = link.getAttribute('href').substring(1);
    if (id) citedIds.add(id);
  });
  
  const items = bibList.querySelectorAll('li');
  let visibleCount = 0;
  items.forEach(item => {
    const anchor = item.querySelector('a[name]');
    const id = anchor ? anchor.getAttribute('name') : null;
    if (id && citedIds.has(id)) {
      item.style.display = '';
      visibleCount++;
      item.setAttribute('value', visibleCount);
    } else {
      item.style.display = 'none';
    }
  });
}

// Highlight reference when citation is clicked
function setupCitationHighlight() {
  const article = document.querySelector('.article');
  if (!article) return;
  
  const citationLinks = article.querySelectorAll('a[href^="#"]');
  citationLinks.forEach(link => {
    link.addEventListener('click', function(e) {
      const id = this.getAttribute('href').substring(1);
      if (!id) return;
      
      // Find the bibliography item with this anchor
      const anchor = document.querySelector('a[name="' + id + '"]');
      if (!anchor) return;
      
      const listItem = anchor.closest('li');
      if (!listItem) return;
      
      // Remove any existing highlights
      document.querySelectorAll('ol.bibliography li.highlight').forEach(el => {
        el.classList.remove('highlight');
      });
      
      // Add highlight class
      listItem.classList.add('highlight');
      
      // Remove highlight after 2 seconds
      setTimeout(() => {
        listItem.classList.remove('highlight');
      }, 2000);
    });
  });
}

// Run after bibliography is built
setTimeout(setupCitationHighlight, 100);

// Table of Contents generation and scroll tracking
function buildTableOfContents() {
  const article = document.querySelector('.article');
  const tocList = document.getElementById('toc-list');
  const tocNav = document.getElementById('toc-nav');
  
  if (!article || !tocList || !tocNav) return;
  
  // Get all h2 and h3 headings in the article
  const headings = article.querySelectorAll('h2, h3');
  
  if (headings.length < 3) {
    // Hide TOC if fewer than 3 headings
    tocNav.style.display = 'none';
    return;
  }
  
  const tocItems = [];
  
  headings.forEach((heading, index) => {
    // Create an ID if the heading doesn't have one
    if (!heading.id) {
      heading.id = 'heading-' + index;
    }
    
    const li = document.createElement('li');
    li.className = 'toc-item' + (heading.tagName === 'H3' ? ' toc-item-h3' : '');
    
    const a = document.createElement('a');
    a.href = '#' + heading.id;
    a.textContent = heading.textContent;
    a.setAttribute('data-heading-id', heading.id);
    
    // Smooth scroll on click
    a.addEventListener('click', function(e) {
      e.preventDefault();
      const target = document.getElementById(heading.id);
      if (target) {
        target.scrollIntoView({ behavior: 'smooth', block: 'start' });
        history.pushState(null, null, '#' + heading.id);
      }
    });
    
    li.appendChild(a);
    tocList.appendChild(li);
    tocItems.push({ id: heading.id, element: heading, link: a });
  });
  
  // Scroll spy: highlight active section
  function updateActiveSection() {
    const scrollPos = window.scrollY + 100; // Offset for header
    
    let activeItem = null;
    
    for (let i = tocItems.length - 1; i >= 0; i--) {
      const item = tocItems[i];
      if (item.element.offsetTop <= scrollPos) {
        activeItem = item;
        break;
      }
    }
    
    // Update active states
    tocItems.forEach(item => {
      item.link.classList.remove('active');
    });
    
    if (activeItem) {
      activeItem.link.classList.add('active');
    }
  }
  
  // Throttled scroll handler
  let ticking = false;
  window.addEventListener('scroll', function() {
    if (!ticking) {
      window.requestAnimationFrame(function() {
        updateActiveSection();
        ticking = false;
      });
      ticking = true;
    }
  });
  
  // Initial update
  updateActiveSection();
}

document.addEventListener('DOMContentLoaded', buildTableOfContents);
</script>
</body>
</html>