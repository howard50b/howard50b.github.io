<html>
<head>
    <title>{{ page.title }}</title>
    <meta charset='UTF-8'>
    <meta content='width=device-width, initial-scale=1' name='viewport'/>

    <meta name='description' content='Gregory Gundersen is a PhD candidate at Princeton.'>
    <meta name='keywords' content='{{ page.keywords }}'>
    <meta name='author' content='Gregory Gundersen'>

    <link rel='shortcut icon' href='/favicon.png' />
    <link href='/css/blog.css' rel='stylesheet'/>
    <link href='/css/trac.css' rel='stylesheet'/>
    <link href='/css/markdown.css' rel='stylesheet'/>

    {% include mathjax.html %}
</head>
<body>
<div class='content'>
    {% include nav.html %}
    <div class='front-matter'>
        <div class='wrap'>
            <h1>{{ page.title }}</h1>
            <div class='bylines'>
                <div class='byline'>
                    <h3>Published</h3>
                    <p>{{ page.date | date: '%d %b %Y' }}</p>
                </div>
            </div>
            <div class='clear'></div>
        </div>
    </div>
    <div class='article-container'>
        <div class='wrap article'>
            {{ content }}
        </div>
        <nav class='toc-nav' id='toc-nav'>
            <div class='toc-header'>Contents</div>
            <ul class='toc-list' id='toc-list'></ul>
        </nav>
    </div>
</div>
<script>
// Auto-filter bibliography: only show cited references, renumber automatically
document.addEventListener('DOMContentLoaded', function() {
  // Find bibliography source (ul or ol after ## References)
  const bibSource = document.querySelector('.bib-source ul, .bib-source ol');
  if (!bibSource) {
    // Fallback to old ol.bibliography format
    const bibList = document.querySelector('ol.bibliography');
    if (bibList) filterOldFormat(bibList);
    return;
  }

  // Find all citation links in the article
  const article = document.querySelector('.article');
  const citationLinks = article.querySelectorAll('a[href^="#"]');
  
  // Collect cited reference IDs in order of appearance and track first occurrence
  const citedIdsOrdered = [];
  const citedIdsSet = new Set();
  const firstCitationId = new Map(); // Maps ref id -> first citation element id
  
  citationLinks.forEach((link, index) => {
    const id = link.getAttribute('href').substring(1);
    if (!id) return;
    
    // Add unique id to citation link for back-linking
    const citationId = 'cite-' + id + '-' + index;
    link.id = citationId;
    
    if (!citedIdsSet.has(id)) {
      citedIdsSet.add(id);
      citedIdsOrdered.push(id);
      firstCitationId.set(id, citationId);
    }
  });

  // Build a map of id -> list item content
  const refMap = new Map();
  const items = bibSource.querySelectorAll('li');
  items.forEach(item => {
    const code = item.querySelector('code');
    if (!code) return;
    
    const id = code.textContent.trim();
    code.remove();
    refMap.set(id, item.innerHTML.trim());
  });

  // Create new ordered list for bibliography, sorted by appearance in text
  const newList = document.createElement('ol');
  newList.className = 'bibliography';
  
  citedIdsOrdered.forEach(id => {
    if (!refMap.has(id)) return;
    
    const li = document.createElement('li');
    const backLinkId = firstCitationId.get(id);
    const backLink = backLinkId ? ' <a href="#' + backLinkId + '" class="back-link" title="Back to text">â†©</a>' : '';
    li.innerHTML = '<a name="' + id + '"></a>' + refMap.get(id) + backLink;
    newList.appendChild(li);
  });

  // Replace source with formatted bibliography
  bibSource.parentNode.replaceChild(newList, bibSource);
});

function filterOldFormat(bibList) {
  const article = document.querySelector('.article');
  const citationLinks = article.querySelectorAll('a[href^="#"]');
  const citedIds = new Set();
  citationLinks.forEach(link => {
    const id = link.getAttribute('href').substring(1);
    if (id) citedIds.add(id);
  });
  
  const items = bibList.querySelectorAll('li');
  let visibleCount = 0;
  items.forEach(item => {
    const anchor = item.querySelector('a[name]');
    const id = anchor ? anchor.getAttribute('name') : null;
    if (id && citedIds.has(id)) {
      item.style.display = '';
      visibleCount++;
      item.setAttribute('value', visibleCount);
    } else {
      item.style.display = 'none';
    }
  });
}

// Highlight reference when citation is clicked
function setupCitationHighlight() {
  const article = document.querySelector('.article');
  if (!article) return;
  
  const citationLinks = article.querySelectorAll('a[href^="#"]');
  citationLinks.forEach(link => {
    link.addEventListener('click', function(e) {
      const id = this.getAttribute('href').substring(1);
      if (!id) return;
      
      // Find the bibliography item with this anchor
      const anchor = document.querySelector('a[name="' + id + '"]');
      if (!anchor) return;
      
      const listItem = anchor.closest('li');
      if (!listItem) return;
      
      // Remove any existing highlights
      document.querySelectorAll('ol.bibliography li.highlight').forEach(el => {
        el.classList.remove('highlight');
      });
      
      // Add highlight class
      listItem.classList.add('highlight');
      
      // Remove highlight after 2 seconds
      setTimeout(() => {
        listItem.classList.remove('highlight');
      }, 2000);
    });
  });
}

// Citation hover tooltip
function setupCitationTooltip() {
  const article = document.querySelector('.article');
  if (!article) return;
  
  // Create tooltip element
  const tooltip = document.createElement('div');
  tooltip.className = 'citation-tooltip';
  document.body.appendChild(tooltip);
  
  // Build a map of reference IDs to their content
  const refContentMap = new Map();
  
  function buildRefMap() {
    const bibList = document.querySelector('ol.bibliography');
    if (!bibList) return;
    
    const items = bibList.querySelectorAll('li');
    items.forEach(item => {
      const anchor = item.querySelector('a[name]');
      if (!anchor) return;
      
      const id = anchor.getAttribute('name');
      // Clone the item content, remove the back-link for tooltip display
      const content = item.cloneNode(true);
      const backLink = content.querySelector('.back-link');
      if (backLink) backLink.remove();
      const anchorInContent = content.querySelector('a[name]');
      if (anchorInContent) anchorInContent.remove();
      
      refContentMap.set(id, content.innerHTML.trim());
    });
  }
  
  // Wait for bibliography to be built, then build ref map
  setTimeout(buildRefMap, 150);
  
  // Find all citation links (links that point to bibliography items)
  const citationLinks = article.querySelectorAll('a[href^="#"]');
  
  let hideTimeout = null;
  let switchTimeout = null;
  let showTimeout = null;
  let activeLink = null;
  let isInsideTooltip = false;
  
  function scheduleHide() {
    if (hideTimeout) clearTimeout(hideTimeout);
    hideTimeout = setTimeout(() => {
      if (!isInsideTooltip) {
        tooltip.classList.remove('visible');
        activeLink = null;
      }
    }, 150);
  }
  
  function cancelHide() {
    if (hideTimeout) {
      clearTimeout(hideTimeout);
      hideTimeout = null;
    }
  }
  
  function cancelSwitch() {
    if (switchTimeout) {
      clearTimeout(switchTimeout);
      switchTimeout = null;
    }
  }
  
  function cancelShow() {
    if (showTimeout) {
      clearTimeout(showTimeout);
      showTimeout = null;
    }
  }
  
  function showTooltipForLink(link, id) {
    const content = refContentMap.get(id);
    if (!content) return;
    
    activeLink = link;
    tooltip.innerHTML = content;
    
    // Position the tooltip near the link
    const rect = link.getBoundingClientRect();
    const tooltipWidth = 400;
    const tooltipHeight = tooltip.offsetHeight || 100;
    
    // Calculate position - prefer below and to the right
    let left = rect.left;
    let top = rect.bottom + 8;
    
    // Adjust if tooltip would go off screen
    if (left + tooltipWidth > window.innerWidth - 20) {
      left = window.innerWidth - tooltipWidth - 20;
    }
    if (left < 20) {
      left = 20;
    }
    
    // If tooltip would go below viewport, show it above the link
    if (top + tooltipHeight > window.innerHeight - 20) {
      top = rect.top - tooltipHeight - 8;
    }
    
    tooltip.style.left = left + 'px';
    tooltip.style.top = top + 'px';
    tooltip.style.maxWidth = Math.min(tooltipWidth, window.innerWidth - 40) + 'px';
    
    tooltip.classList.add('visible');
  }
  
  // Keep tooltip visible when hovering over it
  tooltip.addEventListener('mouseenter', function() {
    isInsideTooltip = true;
    cancelHide();
    cancelSwitch();
  });
  
  tooltip.addEventListener('mouseleave', function() {
    isInsideTooltip = false;
    scheduleHide();
  });
  
  citationLinks.forEach(link => {
    const id = link.getAttribute('href').substring(1);
    if (!id) return;
    
    // Add citation-link class for styling
    link.classList.add('citation-link');
    
    link.addEventListener('mouseenter', function(e) {
      cancelHide();
      cancelShow();
      
      // If tooltip is visible and mouse is inside it, don't switch
      if (isInsideTooltip) return;
      
      // If this is the same link that's already active, do nothing
      if (activeLink === link) return;
      
      // If there's an active tooltip from another link, delay the switch
      // This gives the user time to move into the existing tooltip
      if (activeLink && tooltip.classList.contains('visible')) {
        cancelSwitch();
        switchTimeout = setTimeout(() => {
          switchTimeout = null; // Clear after firing
          if (!isInsideTooltip) {
            showTooltipForLink(link, id);
          }
        }, 100);
      } else {
        // No active tooltip - delay before showing to avoid triggering during scroll
        showTimeout = setTimeout(() => {
          showTimeout = null;
          if (!isInsideTooltip) {
            showTooltipForLink(link, id);
          }
        }, 150);
      }
    });
    
    link.addEventListener('mouseleave', function() {
      // Cancel any pending show (user moved away quickly, likely scrolling)
      cancelShow();
      // Always schedule hide when leaving a link
      // The timeout delay allows moving to the tooltip before it hides
      scheduleHide();
    });
  });
}

// Run after bibliography is built
setTimeout(setupCitationHighlight, 100);
setTimeout(setupCitationTooltip, 200);

// Table of Contents generation and scroll tracking
function buildTableOfContents() {
  const article = document.querySelector('.article');
  const tocList = document.getElementById('toc-list');
  const tocNav = document.getElementById('toc-nav');
  
  if (!article || !tocList || !tocNav) return;
  
  // Get all h2 and h3 headings in the article
  const headings = article.querySelectorAll('h2, h3');
  
  if (headings.length < 3) {
    // Hide TOC if fewer than 3 headings
    tocNav.style.display = 'none';
    return;
  }
  
  const tocItems = [];
  
  headings.forEach((heading, index) => {
    // Create an ID if the heading doesn't have one
    if (!heading.id) {
      heading.id = 'heading-' + index;
    }
    
    const li = document.createElement('li');
    li.className = 'toc-item' + (heading.tagName === 'H3' ? ' toc-item-h3' : '');
    
    const a = document.createElement('a');
    a.href = '#' + heading.id;
    a.textContent = heading.textContent;
    a.setAttribute('data-heading-id', heading.id);
    
    // Smooth scroll on click
    a.addEventListener('click', function(e) {
      e.preventDefault();
      const target = document.getElementById(heading.id);
      if (target) {
        target.scrollIntoView({ behavior: 'smooth', block: 'start' });
        history.pushState(null, null, '#' + heading.id);
      }
    });
    
    li.appendChild(a);
    tocList.appendChild(li);
    tocItems.push({ id: heading.id, element: heading, link: a });
  });
  
  // Scroll spy: highlight active section
  function updateActiveSection() {
    const scrollPos = window.scrollY + 100; // Offset for header
    
    let activeItem = null;
    
    for (let i = tocItems.length - 1; i >= 0; i--) {
      const item = tocItems[i];
      if (item.element.offsetTop <= scrollPos) {
        activeItem = item;
        break;
      }
    }
    
    // Update active states
    tocItems.forEach(item => {
      item.link.classList.remove('active');
    });
    
    if (activeItem) {
      activeItem.link.classList.add('active');
    }
  }
  
  // Throttled scroll handler
  let ticking = false;
  window.addEventListener('scroll', function() {
    if (!ticking) {
      window.requestAnimationFrame(function() {
        updateActiveSection();
        ticking = false;
      });
      ticking = true;
    }
  });
  
  // Initial update
  updateActiveSection();
}

document.addEventListener('DOMContentLoaded', buildTableOfContents);
</script>
</body>
</html>